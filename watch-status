#!/usr/local/bin/python
import git, os.path, signal, sys, threading, watchdog.events, watchdog.observers
from collections import namedtuple
from datetime import datetime, timedelta
from fnmatch import fnmatch
from itertools import islice
from lazy import lazy
from utils import Sh

# wait(None) blocks signals like KeyboardInterrupt
# Use wait(99999) instead
INDEFINITELY = 99999

def fractionalSeconds(delta):
  return delta.total_seconds() + delta.microseconds / 10000000.0

class GitLockWatcher(watchdog.events.FileSystemEventHandler):
  def __init__(self, latency = timedelta(seconds = 0.2)):
    self.latency = latency
    self.observer = None
    self._unlock_timestamp = datetime.utcfromtimestamp(0)
    self._unlocked = threading.Condition()

  @property
  def is_locked(self):
    assert self.observer is not None
    return self._unlock_timestamp is not None and self._unlock_timestamp <= datetime.utcnow()

  def await_unlocked(self):
    while True:
      timeout = (fractionalSeconds(self._unlock_timestamp - datetime.utcnow()) 
                 if self._unlock_timestamp else INDEFINITELY)
      if timeout is not None and timeout <= 0:
        return
      with self._unlocked:
        self._unlocked.wait(timeout)

  def _lock(self):
    self._unlock_timestamp = None

  def _unlock(self):
    with self._unlocked:
      self._unlock_timestamp = datetime.utcnow() + self.latency
      self._unlocked.notify_all()

  def __enter__(self):
    assert self.observer is None
    self.lockfile = '.git/index.lock'
    self.observer = watchdog.observers.Observer()
    self.observer.schedule(self, '.git', recursive = False)
    self.observer.start()
    if os.path.exists(self.lockfile):
      self._lock()
    return self

  def __exit__(self, type, value, traceback):
    self.observer.stop()
    self.observer.join()
    self.observer = None

  def on_created(self, event):
    if event.src_path == self.lockfile:
      self._lock()

  def on_deleted(self, event):
    if event.src_path == self.lockfile:
      self._unlock()

  def on_moved(self, event):
    if event.src_path == self.lockfile:
      self._unlock()
    if event.dest_path == self.lockfile:
      self._lock()

@lazy
class git_status(watchdog.events.FileSystemEventHandler):
  def __call__(self):
    self._git_lock.await_unlocked()
    git.Branch.clear_cache()
    return list(Sh('git', 'status', '--porcelain', '--untracked-files=all'))

  def watch(self, callback):
    self.callback = callback
    self.exclude = frozenset(['.git/*'])
    self.include = frozenset(['.git/index', '.git/HEAD', '.git/refs/heads/*'])
    self.observer = watchdog.observers.Observer()
    self.observer.schedule(self, '.', recursive = True)
    self.observer.start()
    self._git_lock = GitLockWatcher()
    self._git_lock.__enter__()

  def on_any_event(self, event):
    if not event.is_directory:
      path = os.path.normpath(event.src_path)
      any_excluded = any(fnmatch(path, pat) for pat in self.exclude)
      any_included = any(fnmatch(path, pat) for pat in self.include)
      if any_included or not any_excluded:
        self.callback()

  def unwatch(self):
    self.observer.stop()
    #self.observer.join()
    self._git_lock.__exit__(None, None, None)
    self._git_lock = None

@lazy
def show_status():
  rows, columns = window_size()
  sys.stdout.write('\x1b[0;0H\x1b[2J')
  sys.stdout.write('\x1b[1;33m')
  if git.Branch.HEAD is None:
    sys.stdout.write('HEAD detached')
  else:
    sys.stdout.write('On %s' % git.Branch.HEAD.name)
  sys.stdout.write('\x1b[0m')
  for line in islice(git_status(), rows - 1):
    sys.stdout.write('\n')
    if len(line) > columns:
      line = line[0:4] + '...' + line[-(columns - 8):]
    sys.stdout.write(line)
  sys.stdout.flush()

WindowSize = namedtuple('Size', 'rows columns')
@lazy
class window_size:
  def __call__(self):
    return WindowSize(*[int(v) for v in str(Sh('stty', 'size')).split()])

  def watch(self, callback):
    self._callback = callback
    self._next_signal = signal.signal(signal.SIGWINCH, self.resize_event)

  def resize_event(self, signal_num, stack):
    try:
      self._next_signal()
    except TypeError:
      pass
    finally:
      self._callback()

  def unwatch(self):
    signal.signal(signal.SIGWINCH, self._next_signal)

if __name__ == '__main__':
  assert sys.stdout.isatty()
  try:
    show_status.continually()
  except KeyboardInterrupt:
    print

