#!/usr/local/bin/python
# coding=utf-8
"""Usage: git-graph-branch [options]

Symbols:
    ðŸ”·   This branch is in sync with a remote of the same name
    ðŸ”¶   This branch is out of sync with a remote of the same name
    âŒ›   A CI build is in progress for this branch
    ðŸ’š   A CI build has succeeded for this branch
    ðŸ”¥   A CI build has failed for this branch

Options:
    -h --help               Show this screen.
    -w, --watch             Continue to watch for git repo changes after printing the graph.
    --wait-to-merge=<ms>    Waits for this long for the git repo to settle after a change
                            [default: 100].
    --max-update-freq=<ms>  Will not update more frequently than this [default: 500].
    --profile               Profiles the app
    --no-ci                 Do not display continuous integration status indicators
"""
# Observed bugs:
#  1) git branch -f BRANCH commit  -- not noticed by --watch
import heapq, os.path, sys, threading, time, traceback, watchdog.events, watchdog.observers
from bisect import bisect_left
from collections import defaultdict, namedtuple
from datetime import datetime, timedelta
from docopt import docopt
from fnmatch import fnmatch
from git import Branch, git_dir, revparse
from layout import layout
from lazy import lazy, lazy_invalidation
from itertools import chain, cycle, product
from stash import Stash
from travis import TravisClient

def getRemotes():
  return frozenset(b.name for b in Branch.REMOTES)

def alternatingColourIds():
  for lowr,lowb,lowg in product(range(2,-1,-1), repeat=3):
    for highr,highb,highg in [(1,1,0),(1,0,1),(0,1,1),(1,0,0),(0,1,0),(0,1,1)]:
      v = 16 + (highr*3+lowr)*36 + (highg*3+lowg)*6 + (highb*3+lowb)
      yield v

def allChildren(branch):
  allChildren = set()
  todo = [branch]
  while todo:
    b = todo.pop()
    for child in b.children:
      if child not in allChildren:
        todo.append(child)
        allChildren.add(child)
  return allChildren

class BranchBlockers(object):
  def __init__(self, branches):
    self._branches = set(branches)
    self._blockers = {}

  def keys(self):
    return self._branches

  def __len__(self):
    return len(self._branches)

  def __contains__(self, branch):
    return branch in self._branches

  def __getitem__(self, branch):
    if not branch in self._branches:
      raise KeyError(branch)
    if not branch.children:
      return branch
    children = self._blockers.get(branch)
    if children is None:
      self._blockers[branch] = children = list(allChildren(branch))
      children.sort(key = lambda b : b.modtime)
    while children and children[-1] not in self._branches:
      children.pop()
    return self[children[-1]] if children else branch

  def __delitem__(self, branch):
    self._branches.remove(branch)
    if branch in self._blockers:
      del self._blockers[branch]

class PriorityBranchIterator(object):
  def __init__(self, blockers):
    self._blockers = blockers
    self._queue = list(blockers.keys())
    self._queue.sort(key = lambda b: b.modtime)
    self._priorities = []

  def __iter__(self):
    return self

  def next(self):
    blocker = None
    while self._priorities and self._priorities[-1] not in self._blockers:
      self._priorities.pop()
    while self._queue and self._queue[-1] not in self._blockers:
      self._queue.pop()
    if self._priorities:
      blocker = self._blockers[self._priorities[-1]]
    elif self._queue:
      blocker = self._blockers[self._queue[-1]]
    else:
      raise StopIteration()
    assert blocker in self._blockers
    self._priorities.extend(p for p in blocker.parents
                            if p in self._blockers and p not in self._priorities)
    del self._blockers[blocker]
    return blocker

@lazy
def layoutAllBranches():
  branches = sorted(Branch.ALL, key = lambda b : b.modtime or datetime.fromtimestamp(1))
  branches = tuple(PriorityBranchIterator(BranchBlockers(branches)))
  return zip(branches, layout(branches))

def printGraph(clearScreen = False, ciTypes = ()):
  ciTools = [ciType() for ciType in ciTypes]
  remotes = getRemotes()
  remoteHashes = dict(zip(remotes, revparse(*remotes).splitlines()))
  localsWithRemotes = defaultdict(set)
  for r in remotes:
    localsWithRemotes[r.split('/', 1)[-1]].add(r)

  done = set()
  awaitingParents = []
  firstChilds = []

  if clearScreen:
    sys.stdout.write('\x1b[0;0H')

  if sys.stdout.isatty():
    def control(chars):
      sys.stdout.write(chars)
  else:
    def control(chars):
      pass

  def branchLabel(b):
    if b == Branch.HEAD:
      control('\x1b[1;35m')
    sys.stdout.write(b.name)
    control('\x1b[0m')
    if b.name in localsWithRemotes:
      sys.stdout.write(' ')
      version = b.allCommits[0].hash
      if any(remoteHashes[r] != version for r in localsWithRemotes[b.name]):
        sys.stdout.write('ðŸ”¶ ')
      else:
        sys.stdout.write('ðŸ”· ')
    ciStatuses = [ status for tool in ciTools for status in tool.ciStatus(b).values() ]
    if ciStatuses:
      sys.stdout.write(' ')
      for status in ciStatuses:
        if status == 'orange':
          sys.stdout.write('âŒ› ')
        elif status == 'green':
          sys.stdout.write('ðŸ’š ')
        else:
          sys.stdout.write('ðŸ”¥ ')
    if b.unmerged > 0:
      sys.stdout.write(' ')
      control('\x1b[1;31m')
      if b.unmerged <= 20:
        sys.stdout.write((u'%s unmerged' % unichr(0x245F + b.unmerged)).encode('UTF-8'))
      else:
        sys.stdout.write(" [%d unmerged]" % b.unmerged)
      control('\x1b[0m')
    if clearScreen:
      control('\x1b[K')
    return ""

  for b, row in layoutAllBranches():
    sys.stdout.write(unicode(row).encode('UTF-8'))
    sys.stdout.write('  ')
    branchLabel(b)
    sys.stdout.write('\n')

  if clearScreen:
    control('\x1b[J')
    sys.stdout.flush()

def fractionalSeconds(delta):
  return delta.total_seconds() + delta.microseconds / 10000000.0

def sleepUntil(dt):
  waitSecs = fractionalSeconds(dt - datetime.utcnow())
  if waitSecs > 0:
    time.sleep(waitSecs)

class Watcher(watchdog.events.FileSystemEventHandler):
  def __init__(self, path, patterns, waitToMerge, maxUpdateFreq):
    self.path = path
    self.patterns = patterns
    self.event = threading.Event()
    self.lastEvent = None
    self.lastSeen = None
    self.waitToMerge = waitToMerge
    self.maxUpdateFreq = maxUpdateFreq

  def __enter__(self):
    self.observer = watchdog.observers.Observer()
    self.observer.schedule(self, self.path, recursive = True)
    self.observer.start()
    self.notBefore = datetime.utcnow()
    return self

  def __exit__(self, type, value, traceback):
    self.observer.stop()
    self.observer = None

  def on_any_event(self, event):
    src_match = any(fnmatch(event.src_path, pattern) for pattern in self.patterns)
    try:
      dest_match = any(fnmatch(event.dest_path, pattern) for pattern in self.patterns)
    except AttributeError:
      dest_match = False
    if src_match or dest_match:
      self.lastEvent = datetime.utcnow()
      self.event.set()

  def lastEvent(self):
    self.lastSeen = self.lastEvent
    return self.lastSeen

  def awaitEvent(self):
    sleepUntil(self.notBefore)
    seen = self.lastEvent
    while self.lastSeen is seen:
      self.event.wait()
      self.event.clear()
      seen = self.lastEvent
    while True:
      waitSecs = fractionalSeconds(seen + self.waitToMerge - datetime.utcnow())
      if waitSecs <= 0:
        break
      time.sleep(waitSecs)
      seen = self.lastEvent
    self.lastSeen = seen
    self.notBefore = datetime.utcnow() + self.maxUpdateFreq

def filesToWatch(gitdir):
  head = os.path.join(gitdir, 'HEAD')
  config = os.path.join(gitdir, 'config')
  branches = os.path.join(gitdir, 'refs', 'heads', '*')
  remotes = os.path.join(gitdir, 'refs', 'remotes', '*', '*')
  return [head, config, branches, remotes]

def watchForChanges(waitToMerge, maxUpdateFreq, action):
  with lazy_invalidation():
    action.continually()

def getPrintGraphArgs(options):
  def select(name, **algorithms):
    try:
      return algorithms[options[name]]
    except KeyError:
      sys.stderr.write('%s not a valid choice for %s (must be one of: %s)'
                       % (options[name], name, ", ".join(algorithms.keys())))
  return {
    'ciTypes' : () if options['--no-ci'] else (Stash, TravisClient)
  }

if __name__ == '__main__':
  options = docopt(__doc__)
  printGraphArgs = getPrintGraphArgs(options)
  if options['--watch']:
    assert sys.stdout.isatty()
    try:
      @lazy
      def action():
        try:
          printGraph(clearScreen = True, **printGraphArgs)
        except Exception:
          sys.stdout.write('\n')
          sys.stdout.flush()
          traceback.print_exc(3)
          sys.stdout.write('\x1b[J')
          sys.stdout.flush()
      with lazy_invalidation():
        action.continually()
    except KeyboardInterrupt:
      pass
  elif options['--profile']:
    import cProfile
    cProfile.run('printGraph(**printGraphArgs)')
  else:
    printGraph(**printGraphArgs)

