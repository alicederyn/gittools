#!/usr/bin/python
# coding=utf-8
"""Usage: git-graph-branch [options]

Symbols:
    ðŸ”·   This branch has a remote of the same name
    ðŸ”¶   This branch is out of sync with a remote of the same name
    âŒ›   A CI build is in progress for this branch
    ðŸ’š   A CI build has succeeded for this branch
    ðŸ”¥   A CI build has failed for this branch

Options:
    -h --help               Show this screen.
    -w, --watch             Continue to watch for git repo changes after printing the graph.
    --wait-to-merge=<ms>    Waits for this long for the git repo to settle after a change
                            [default: 100].
    --max-update-freq=<ms>  Will not update more frequently than this [default: 500].
    --color                 Colorizes branches
    --profile               Profiles the app
    --order-algo=<algo>     Algorithm to select the next branch to unblock.
                            One of: simple, priority [default: priority]
"""
# Observed bugs:
#  1) git branch -f BRANCH commit  -- not noticed by --watch
import heapq, os.path, sh, sys, threading, time, traceback, watchdog.events, watchdog.observers
from bisect import bisect_left
from collections import defaultdict, namedtuple
from datetime import datetime, timedelta
from docopt import docopt
from fnmatch import fnmatch
from itertools import chain, cycle, product
from travis import TravisClient
from utils import Branch, revparse

def getBranches():
  """Returns all branches, oldest first."""
  return sorted(Branch.ALL, key = lambda b : b.modtime or datetime.fromtimestamp(1))

def getRemotes():
  return frozenset(b.name for b in Branch.REMOTES)

def alternatingColourIds():
  for lowr,lowb,lowg in product(range(2,-1,-1), repeat=3):
    for highr,highb,highg in [(1,1,0),(1,0,1),(0,1,1),(1,0,0),(0,1,0),(0,1,1)]:
      v = 16 + (highr*3+lowr)*36 + (highg*3+lowg)*6 + (highb*3+lowb)
      yield v

def allChildren(branch):
  allChildren = set()
  todo = [branch]
  while todo:
    b = todo.pop()
    for child in b.children:
      if child not in allChildren:
        todo.append(child)
        allChildren.add(child)
  return allChildren

class BranchBlockers(object):
  def __init__(self, branches):
    self._branches = set(branches)
    self._blockers = {}

  def keys(self):
    return self._branches

  def __len__(self):
    return len(self._branches)

  def __contains__(self, branch):
    return branch in self._branches

  def __getitem__(self, branch):
    if not branch in self._branches:
      raise KeyError(branch)
    if not branch.children:
      return branch
    children = self._blockers.get(branch)
    if children is None:
      self._blockers[branch] = children = list(allChildren(branch))
      children.sort(key = lambda b : b.modtime)
    while children and children[-1] not in self._branches:
      children.pop()
    return self[children[-1]] if children else branch

  def __delitem__(self, branch):
    self._branches.remove(branch)
    if branch in self._blockers:
      del self._blockers[branch]

class PriorityBranchIterator(object):
  def __init__(self, blockers):
    self._blockers = blockers
    self._queue = list(blockers.keys())
    self._queue.sort(key = lambda b: b.modtime)
    self._priorities = []

  def __iter__(self):
    return self

  def next(self):
    blocker = None
    while self._priorities and self._priorities[-1] not in self._blockers:
      self._priorities.pop()
    while self._queue and self._queue[-1] not in self._blockers:
      self._queue.pop()
    if self._priorities:
      blocker = self._blockers[self._priorities[-1]]
    elif self._queue:
      blocker = self._blockers[self._queue[-1]]
    else:
      raise StopIteration()
    assert blocker in self._blockers
    self._priorities.extend(p for p in blocker.parents
                            if p in self._blockers and p not in self._priorities)
    del self._blockers[blocker]
    return blocker

class SimpleBranchIterator(object):
  def __init__(self, blockers):
    self._blockers = blockers
    self._roots = list(b for b in blockers.keys()
                       if not any(p in self._blockers for p in b.parents))
    self._roots.sort(key = lambda b: b.modtime)
    self._currentRoots = []

  def __iter__(self):
    return self

  def next(self):
    if not self._currentRoots:
      while self._roots and self._roots[-1] not in self._blockers:
        self._roots.pop()
      if not self._roots:
        raise StopIteration()
      self._currentRoots.append(self._roots.pop())
    blocker = self._blockers[self._currentRoots[0]]
    if self._currentRoots[0] is blocker:
      self._currentRoots.pop(0)
    del self._blockers[blocker]
    return blocker

def localParents(b, remotes):
  return [p for p in b.parents if not p.name in remotes]

def getColour(branch, remotes, colours, colourseq):
  if branch is None or colourseq is None:
    return 0
  if branch not in colours:
    if len(branch.children) == 0:
      if len(localParents(branch, remotes)) == 0:
        colours[branch] = None
      else:
        colours[branch] = colourseq.next()
    elif len(branch.children) == 1:
      colours[branch] = getColour(iter(branch.children).next(), colours, colourseq)
    else:
      colours[branch] = colourseq.next()
  return colours[branch]

def setColour(colour):
  if colour:
    sys.stdout.write('\x1b[%s' % colour)

def printGraph(color, BranchIterator, clearScreen = False):
  branches = getBranches()
  remotes = getRemotes()
  remoteHashes = dict(zip(remotes, revparse(*remotes).splitlines()))
  localsWithRemotes = defaultdict(set)
  for r in remotes:
    localsWithRemotes[r.split('/', 1)[-1]].add(r)

  done = set()
  awaitingParents = []
  firstChilds = []
  colours = {}
  if color:
    colourseq = cycle(('38;5;%dm' % i for i in alternatingColourIds()))
  else:
    colourseq = None
  travis = TravisClient()

  if clearScreen:
    sys.stdout.write('\x1b[0;0H')

  for b in BranchIterator(BranchBlockers(branches)):
    assert b not in done
    done.add(b)
    colour = getColour(b, remotes, colours, colourseq)
    try:
      index = awaitingParents.index(b)
    except ValueError:
      index = len(awaitingParents)
    parentIndices = [i for i, p in enumerate(awaitingParents) if p in localParents(b, remotes)]
    missingParents = [p for p in localParents(b, remotes)
                      if p not in awaitingParents and p not in done]
    if missingParents:
      parentIndices.append(index)
      if len(missingParents) > 1:
        parentIndices.append(len(awaitingParents) + len(missingParents) - 2)
      arrowhead = 'â—‡'
    else:
      arrowhead = 'â–¶'
    firstIndex = min([index] + parentIndices)
    lastIndex = max([index] + parentIndices)
    sys.stdout.write(' ')
    for i, a in enumerate(awaitingParents):
      if a and sum(1 for c in a.children if c not in done) == 1:
        aColour = getColour(firstChilds[i], remotes, colours, colourseq)
      else:
        aColour = getColour(a, remotes, colours, colourseq)
      setColour(aColour)
      if a is None:
        if firstIndex < i <= lastIndex:
          sys.stdout.write('â”€')
        else:
          sys.stdout.write(' ')
      elif a == b:
        if not missingParents:
          if i <= firstIndex and i < lastIndex:
            sys.stdout.write('â•°')
          else:
            sys.stdout.write('â”´')
        else:
          sys.stdout.write('â”œ')
      elif i < firstIndex:
        sys.stdout.write('â”‚')
      elif i <= lastIndex:
        if i not in parentIndices:
          sys.stdout.write('â”‚')
        elif i == firstIndex:
          sys.stdout.write('â”œ')
        else:
          sys.stdout.write('â”¼')
      else:
        sys.stdout.write('â”‚')
      sys.stdout.write('\x1b[0m')
      setColour(colour)
      if i < firstIndex:
        sys.stdout.write(' ')
      elif i < lastIndex:
        if a is not None and a != b and (i not in parentIndices or (i + 1) not in parentIndices):
          sys.stdout.write('â”„')  # Untested, may not work
        else:
          sys.stdout.write('â”€')
      elif i == lastIndex:
        sys.stdout.write(arrowhead)
      else:
        sys.stdout.write(' ')
      sys.stdout.write('\x1b[0m')
    newColumns = missingParents if index == len(awaitingParents) else missingParents[1:]
    for a in newColumns[:-1]:
      aColour = getColour(a, remotes, colours, colourseq)
      setColour(aColour)
      if a == firstIndex:
        sys.stdout.write('â”Œâ”€')
      else:
        sys.stdout.write('â”¬â”€')
      sys.stdout.write('\x1b[0m')
    if lastIndex >= len(awaitingParents):
      setColour(colour)
      if missingParents:
        if firstIndex == lastIndex and len(b.parents) == 1:
          sys.stdout.write('â”Œ')
        else:
          sys.stdout.write('â”¬')
      else:
        sys.stdout.write('â”€')
      sys.stdout.write(arrowhead)
      sys.stdout.write('\x1b[0m')
    sys.stdout.write('  ')
    if b == Branch.HEAD:
      sys.stdout.write('\x1b[1;35m')
    sys.stdout.write(b.name)
    sys.stdout.write('\x1b[0m')
    if b.name in localsWithRemotes:
      sys.stdout.write(' ')
      version = b.allCommits[0].hash
      if any(remoteHashes[r] != version for r in localsWithRemotes[b.name]):
        sys.stdout.write('ðŸ”¶ ')
      else:
        sys.stdout.write('ðŸ”· ')
    ciStatuses = travis.ciStatus(b).values()
    if ciStatuses:
      sys.stdout.write(' ')
      for status in ciStatuses:
        if status == 'orange':
          sys.stdout.write('âŒ› ')
        elif status == 'green':
          sys.stdout.write('ðŸ’š ')
        else:
          sys.stdout.write('ðŸ”¥ ')
    if b.unmerged > 0:
      sys.stdout.write(' ')
      sys.stdout.write('\x1b[1;31m')
      if b.unmerged <= 20:
        sys.stdout.write('%s unmerged' % unichr(0x245F + b.unmerged))
      else:
        sys.stdout.write(" [%d unmerged]" % b.unmerged)
      sys.stdout.write('\x1b[0m')
    if clearScreen:
      sys.stdout.write('\x1b[K')
    sys.stdout.write('\n')
    if missingParents:
      if index != len(awaitingParents):
        awaitingParents[index] = missingParents[0]
        firstChilds[index] = b
        awaitingParents.extend(missingParents[1:])
        firstChilds.extend([b] * (len(missingParents) - 1))
      else:
        awaitingParents.extend(missingParents)
        firstChilds.extend([b] * len(missingParents))
    elif index == len(awaitingParents):
      pass
    else:
      awaitingParents[index] = None
      while awaitingParents and awaitingParents[-1] is None:
        awaitingParents.pop()
        firstChilds.pop()
    assert len(set(p for p in awaitingParents if p)) == len([p for p in awaitingParents if p])
  if clearScreen:
    sys.stdout.write('\x1b[J')
    sys.stdout.flush()

def fractionalSeconds(delta):
  return delta.total_seconds() + delta.microseconds / 10000000.0

def sleepUntil(dt):
  waitSecs = fractionalSeconds(dt - datetime.utcnow())
  if waitSecs > 0:
    time.sleep(waitSecs)

class Watcher(watchdog.events.FileSystemEventHandler):
  def __init__(self, path, patterns, waitToMerge, maxUpdateFreq):
    self.path = path
    self.patterns = patterns
    self.event = threading.Event()
    self.lastEvent = None
    self.lastSeen = None
    self.waitToMerge = waitToMerge
    self.maxUpdateFreq = maxUpdateFreq

  def __enter__(self):
    self.observer = watchdog.observers.Observer()
    self.observer.schedule(self, self.path, recursive = True)
    self.observer.start()
    self.notBefore = datetime.utcnow()
    return self

  def __exit__(self, type, value, traceback):
    self.observer.stop()
    self.observer = None

  def on_any_event(self, event):
    if any(fnmatch(event.src_path, pattern) for pattern in self.patterns):
      self.lastEvent = datetime.utcnow()
      self.event.set()

  def lastEvent(self):
    self.lastSeen = self.lastEvent
    return self.lastSeen

  def awaitEvent(self):
    sleepUntil(self.notBefore)
    seen = self.lastEvent
    while self.lastSeen is seen:
      self.event.wait()
      self.event.clear()
      seen = self.lastEvent
    while True:
      waitSecs = fractionalSeconds(seen + self.waitToMerge - datetime.utcnow())
      if waitSecs <= 0:
        break
      time.sleep(waitSecs)
      seen = self.lastEvent
    self.lastSeen = seen
    self.notBefore = datetime.utcnow() + self.maxUpdateFreq

def watchForChanges(waitToMerge, maxUpdateFreq, action):
  gitdir = revparse(git_dir=True)
  head = os.path.join(gitdir, 'HEAD')
  branches = os.path.join(gitdir, 'refs', 'heads', '*')
  remotes = os.path.join(gitdir, 'refs', 'remotes', '*', '*')
  with Watcher(gitdir, [head, branches, remotes], waitToMerge, maxUpdateFreq) as watcher:
    while True:
      Branch.clear_cache()
      action()
      watcher.awaitEvent()

def getPrintGraphArgs(options):
  def select(name, **algorithms):
    try:
      return algorithms[options[name]]
    except KeyError:
      sys.stderr.write('%s not a valid choice for %s (must be one of: %s)'
                       % (options[name], name, ", ".join(algorithms.keys())))
  return {
    'color'          : options['--color'],
    'BranchIterator' : select('--order-algo',   simple   = SimpleBranchIterator,
                                                priority = PriorityBranchIterator),
  }

if __name__ == '__main__':
  options = docopt(__doc__)
  printGraphArgs = getPrintGraphArgs(options)
  if options['--watch']:
    try:
      def action():
        try:
          printGraph(clearScreen = True, **printGraphArgs)
        except Exception:
          sys.stdout.write('\n')
          sys.stdout.flush()
          traceback.print_exc(3)
          sys.stdout.write('\x1b[J')
          sys.stdout.flush()
      watchForChanges(
          waitToMerge = timedelta(milliseconds = int(options['--wait-to-merge'])),
          maxUpdateFreq = timedelta(milliseconds = int(options['--max-update-freq'])),
          action = action)
    except KeyboardInterrupt:
      pass
  elif options['--profile']:
    import cProfile
    cProfile.run('printGraph(**printGraphArgs)')
  else:
    printGraph(**printGraphArgs)

