#!/usr/bin/python
# coding=utf-8
"""Usage: git-graph-branch [options]

Symbols:
    ⇧   This branch has a remote of the same name
    ⚠   This branch is out of sync with a remote of the same name

Options:
    -h --help               Show this screen.
    -w, --watch             Continue to watch for git repo changes after printing the graph.
    --wait-to-merge=<ms>    Waits for this long for the git repo to settle after a change
                            [default: 100].
    --max-update-freq=<ms>  Will not update more frequently than this [default: 500].
    --color                 Colorizes branches
"""
# Observed bugs:
#  1) git branch -f BRANCH commit  -- not noticed by --watch
import os.path, sh, sys, time, traceback, watchdog.events, watchdog.observers
from bisect import bisect_left
from collections import defaultdict, namedtuple
from datetime import datetime, timedelta
from docopt import docopt
from itertools import chain, cycle, product
from utils import Branch, revparse

def getBranches():
  """Returns all branches, oldest first."""
  return sorted(Branch.ALL, key = lambda b : b.modtime or datetime.fromtimestamp(1))

def getRemotes():
  return frozenset(t.strip() for t in sh.git.branch('--remotes', _tty_out=False, _iter=True))

def alternatingColourIds():
  for lowr,lowb,lowg in product(range(2,-1,-1), repeat=3):
    for highr,highb,highg in [(1,1,0),(1,0,1),(0,1,1),(1,0,0),(0,1,0),(0,1,1)]:
      v = 16 + (highr*3+lowr)*36 + (highg*3+lowg)*6 + (highb*3+lowb)
      yield v

def pickNext(awaitingParents, todo, done):
  candidate = awaitingParents[-1] if awaitingParents else todo[0]
  def youngestBranchLeaf(b):
    leaves = [youngestBranchLeaf(c) for c in b.children if c not in done]
    if leaves:
      age, youngest = max(leaves)
      return (max(age, b.modtime), youngest)
    else:
      return (b.modtime, b)
  return youngestBranchLeaf(candidate)[1]

def localParents(b, remotes):
  return [p for p in b.parents if not p.name in remotes]

def getColour(branch, remotes, colours, colourseq):
  if branch is None or colourseq is None:
    return 0
  if branch not in colours:
    if len(branch.children) == 0:
      if len(localParents(branch, remotes)) == 0:
        colours[branch] = None
      else:
        colours[branch] = colourseq.next()
    elif len(branch.children) == 1:
      colours[branch] = getColour(iter(branch.children).next(), colours, colourseq)
    else:
      colours[branch] = colourseq.next()
  return colours[branch]

def setColour(colour):
  if colour:
    sys.stdout.write('\x1b[%s' % colour)

def printGraph(clearScreen = False, color = False):
  branches = getBranches()
  remotes = getRemotes()
  localsWithRemotes = defaultdict(set)
  for r in remotes:
    localsWithRemotes[r.split('/', 1)[-1]].add(r)
  try:
    currentBranch = Branch(revparse("--abbrev-ref", "HEAD"))
  except ValueError:
    currentBranch = None
 
  done = set()
  todo = list(branches)
  todo.reverse()
  awaitingParents = []
  firstChilds = []
  colours = {}
  if color:
    colourseq = cycle(('38;5;%dm' % i for i in alternatingColourIds()))
  else:
    colourseq = None
 
  if clearScreen:
    sys.stdout.write('\x1b[0;0H')
  while todo or awaitingParents:
    b = pickNext(awaitingParents, todo, done)
    assert not any (x in done for x in todo)
    assert not any (c in todo for c in b.children)
    todo = [x for x in todo if x != b]
    done.add(b)
    colour = getColour(b, remotes, colours, colourseq)
    try:
      index = awaitingParents.index(b)
    except ValueError:
      index = len(awaitingParents)
    parentIndices = [i for i, p in enumerate(awaitingParents) if p in localParents(b, remotes)]
    missingParents = [p for p in localParents(b, remotes)
                      if p not in awaitingParents and p not in done]
    if missingParents:
      parentIndices.append(index)
      if len(missingParents) > 1:
        parentIndices.append(len(awaitingParents) + len(missingParents) - 2)
      arrowhead = '◇'
    else:
      arrowhead = '▶'
    firstIndex = min([index] + parentIndices)
    lastIndex = max([index] + parentIndices)
    sys.stdout.write(' ')
    for i, a in enumerate(awaitingParents):
      if a and sum(1 for c in a.children if c not in done) == 1:
        aColour = getColour(firstChilds[i], remotes, colours, colourseq)
      else:
        aColour = getColour(a, remotes, colours, colourseq)
      setColour(aColour)
      if a is None:
        if firstIndex < i <= lastIndex:
          sys.stdout.write('─')
        else:
          sys.stdout.write(' ')
      elif a == b:
        if not missingParents:
          if i <= firstIndex and i < lastIndex:
            sys.stdout.write('╰')
          else:
            sys.stdout.write('┴')
        else:
          sys.stdout.write('├')
      elif i < firstIndex:
        sys.stdout.write('│')
      elif i <= lastIndex:
        if i not in parentIndices:
          sys.stdout.write('╪')
        elif i == firstIndex:
          sys.stdout.write('├')
        else:
          sys.stdout.write('┼')
      else:
        sys.stdout.write('│')
      sys.stdout.write('\x1b[0m')
      setColour(colour)
      if i < firstIndex:
        sys.stdout.write(' ')
      elif i < lastIndex:
        sys.stdout.write('─')
      elif i == lastIndex:
        sys.stdout.write(arrowhead)
      else:
        sys.stdout.write(' ')
      sys.stdout.write('\x1b[0m')
    newColumns = missingParents if index == len(awaitingParents) else missingParents[1:]
    for a in newColumns[:-1]:
      aColour = getColour(a, remotes, colours, colourseq)
      setColour(aColour)
      if a == firstIndex:
        sys.stdout.write('┌─')
      else:
        sys.stdout.write('┬─')
      sys.stdout.write('\x1b[0m')
    if lastIndex >= len(awaitingParents):
      setColour(colour)
      if missingParents:
        if firstIndex == lastIndex:
          sys.stdout.write('┌')
        else:
          sys.stdout.write('┬')
      else:
        sys.stdout.write('─')
      sys.stdout.write(arrowhead)
      sys.stdout.write('\x1b[0m')
    sys.stdout.write('  ')
    if b == currentBranch:
      sys.stdout.write('\x1b[1;35m')
    sys.stdout.write(b.name)
    sys.stdout.write('\x1b[0m')
    if b.name in localsWithRemotes:
      sys.stdout.write(' ')
      version = revparse(b.name)
      if any(revparse(r) != version for r in localsWithRemotes[b.name]):
        sys.stdout.write('\x1b[1;31m')
        sys.stdout.write('⚠')
        sys.stdout.write('\x1b[0m')
      else:
        sys.stdout.write('⇧')
    if b.unmerged > 0:
      sys.stdout.write('\x1b[1;31m')
      sys.stdout.write(" [%d unmerged]" % b.unmerged)
      sys.stdout.write('\x1b[0m')
    if clearScreen:
      sys.stdout.write('\x1b[K')
    sys.stdout.write('\n')
    if missingParents:
      if index != len(awaitingParents):
        awaitingParents[index] = missingParents[0]
        firstChilds[index] = b
        awaitingParents.extend(missingParents[1:])
        firstChilds.extend([b] * (len(missingParents) - 1))
      else:
        awaitingParents.extend(missingParents)
        firstChilds.extend([b] * len(missingParents))
    elif index == len(awaitingParents):
      pass
    else:
      awaitingParents[index] = None
      while awaitingParents and awaitingParents[-1] is None:
        awaitingParents.pop()
        firstChilds.pop()
    assert len(set(p for p in awaitingParents if p)) == len([p for p in awaitingParents if p])
  if clearScreen:
    sys.stdout.write('\x1b[J')
    sys.stdout.flush()

def total_milliseconds(delta):
  return delta.total_seconds() * 1000 + delta.microseconds // 1000

def sleepUntil(dt):
  waitSecs = total_milliseconds(dt - datetime.utcnow()) / 1000.0
  if waitSecs > 0:
    time.sleep(waitSecs)

class Watcher(watchdog.events.FileSystemEventHandler):
  def __init__(self, path):
    self.observer = watchdog.observers.Observer()
    self.observer.schedule(self, path, recursive = True)
    self.eventReceived = False
  
  def __enter__(self):
    self.observer.start()
    return self

  def __exit__(self, type, value, traceback):
    self.observer.stop()

  def on_any_event(self, event):
    self.eventReceived = True

  def awaitEvent(self):
    while not self.eventReceived:
      time.sleep(1)
    self.eventReceived = False

def watchForChanges(waitToMerge, maxUpdateFreq, color):
  gitdir = revparse(git_dir=True)
  logsdir = os.path.join(gitdir, 'logs')
  config = os.path.realpath(os.path.join(gitdir, 'config'))
  with Watcher(logsdir) as watcher:
    while True:
      nextEarliestUpdate = datetime.utcnow() + maxUpdateFreq - waitToMerge
      Branch.clear_cache()
      try:
        printGraph(clearScreen = True, color = color)
      except Exception:
        sys.stdout.write('\n')
        sys.stdout.flush()
        traceback.print_exc(3)
        sys.stdout.write('\x1b[J')
        sys.stdout.flush()
      sleepUntil(nextEarliestUpdate)
      watcher.awaitEvent()

if __name__ == '__main__':
  arguments = docopt(__doc__)
  if arguments['--watch']:
    try:
      watchForChanges(
          waitToMerge = timedelta(milliseconds = int(arguments['--wait-to-merge'])),
          maxUpdateFreq = timedelta(milliseconds = int(arguments['--max-update-freq'])),
          color = arguments['--color'])
    except KeyboardInterrupt:
      pass
  else:
    printGraph(clearScreen=False, color = arguments['--color'])

