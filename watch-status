#!/usr/local/bin/python
import git, os.path, signal, sys, threading, watchdog.events, watchdog.observers
from collections import namedtuple
from datetime import datetime, timedelta
from fnmatch import fnmatch
from git import git_dir, GitLockWatcher, LazyGitFunction
from itertools import islice
from lazy import lazy, lazy_invalidation
from utils import Sh

# wait(None) blocks signals like KeyboardInterrupt
# Use wait(99999) instead
INDEFINITELY = 99999

@lazy
class git_status(LazyGitFunction):
  def __init__(self):
    LazyGitFunction.__init__(self,
                             root_dir = os.path.join(git_dir(), '..'),
                             exclude_globs = ['.git/*'],
                             include_globs = ['.git/index', '.git/refs/heads/*'])

  def __call__(self):
    self._git_lock.await_unlocked()
    return list(Sh('git', 'status', '--porcelain', '--untracked-files=all'))

  def watch(self, callback):
    LazyGitFunction.watch(self, callback)
    self._git_lock = GitLockWatcher()
    self._git_lock.__enter__()

  def unwatch(self):
    LazyGitFunction.unwatch(self)
    self._git_lock.__exit__(None, None, None)
    self._git_lock = None

@lazy
def show_status():
  rows, columns = window_size()
  sys.stdout.write('\x1b[0;0H\x1b[2J')
  sys.stdout.write('\x1b[1;33m')
  if git.Branch.HEAD is None:
    sys.stdout.write('HEAD detached')
  else:
    sys.stdout.write('On %s' % git.Branch.HEAD.name)
  sys.stdout.write('\x1b[0m')
  for line in islice(git_status(), rows - 1):
    sys.stdout.write('\n')
    if len(line) > columns:
      line = line[0:4] + '...' + line[-(columns - 8):]
    sys.stdout.write(line)
  sys.stdout.flush()

WindowSize = namedtuple('Size', 'rows columns')
@lazy
class window_size:
  def __call__(self):
    return WindowSize(*[int(v) for v in str(Sh('stty', 'size')).split()])

  def watch(self, callback):
    self._callback = callback
    self._next_signal = signal.signal(signal.SIGWINCH, self.resize_event)

  def resize_event(self, signal_num, stack):
    try:
      self._next_signal()
    except TypeError:
      pass
    finally:
      self._callback()

  def unwatch(self):
    signal.signal(signal.SIGWINCH, self._next_signal)

if __name__ == '__main__':
  assert sys.stdout.isatty()
  try:
    with lazy_invalidation():
      show_status.continually()
  except KeyboardInterrupt:
    print

